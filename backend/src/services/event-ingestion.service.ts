import { supabase } from '../config/supabase';
import { allocateSequenceId, validateSequenceId } from './sequence-id.service';
import {
  buildInitialAuditMetadata,
  AuditActor,
  NetworkContext,
} from '../../../shared/src/eld/audit-trail';
import { createHash } from 'crypto';

interface IngestEventParams {
  eventType: number;
  eventSubType?: number;
  eventRecordStatus: number;
  eventRecordOrigin: number;
  eventDate: string;
  eventTime: string;
  timezoneOffset: string;
  eldDeviceId: string;
  driverEldAccountId?: string;
  carrierDotNumber?: string;
  metadata: Record<string, unknown>;
  actor: AuditActor;
  network?: NetworkContext;
  sequenceId?: number; // Optional - will be allocated if not provided
}

interface IngestEventResult {
  eventId: string;
  sequenceId: number;
  chainHash: string;
}

function sha256(input: string): string {
  return createHash('sha256').update(input, 'utf8').digest('hex');
}

/**
 * Ingests a new ELD event with full audit trail and hash chain verification.
 */
export async function ingestEvent(params: IngestEventParams): Promise<IngestEventResult> {
  const {
    eventType,
    eventSubType,
    eventRecordStatus,
    eventRecordOrigin,
    eventDate,
    eventTime,
    timezoneOffset,
    eldDeviceId,
    driverEldAccountId,
    carrierDotNumber,
    metadata,
    actor,
    network,
    sequenceId: providedSequenceId,
  } = params;

  // Determine log_period_id (YYYYMMDD format)
  const logPeriodId = eventDate;

  // Allocate or validate sequence ID
  let sequenceId: number;
  if (providedSequenceId !== undefined) {
    const validation = await validateSequenceId(eldDeviceId, eventDate, providedSequenceId);
    if (!validation.valid) {
      throw new Error(`Invalid sequence ID: ${validation.reason}`);
    }
    sequenceId = providedSequenceId;
  } else {
    sequenceId = await allocateSequenceId(eldDeviceId, eventDate);
  }

  // Fetch previous event's chain hash
  const { data: prevEvent } = await supabase
    .from('eld_events')
    .select('chain_hash')
    .eq('eld_device_id', eldDeviceId)
    .eq('log_period_id', logPeriodId)
    .eq('event_record_status', 1)
    .order('event_sequence_id', { ascending: false })
    .limit(1)
    .maybeSingle();

  const prevChainHash = prevEvent?.chain_hash || '';

  // Parse event timestamp
  // IMPORTANT: event_timestamp is the PARTITION KEY for eld_events table.
  // PostgreSQL will automatically route this INSERT to the correct monthly partition.
  // If no partition exists for this timestamp, the INSERT will fail.
  const year = `20${eventDate.substring(4, 6)}`;
  const month = eventDate.substring(0, 2);
  const day = eventDate.substring(2, 4);
  const hour = eventTime.substring(0, 2);
  const minute = eventTime.substring(2, 4);
  const second = eventTime.substring(4, 6);
  const tzSign = timezoneOffset[0];
  const tzHour = timezoneOffset.substring(1, 3);
  const tzMin = timezoneOffset.substring(3, 5);
  const eventTimestamp = `${year}-${month}-${day}T${hour}:${minute}:${second}${tzSign}${tzHour}:${tzMin}`;

  // Build audit metadata with hash chain
  const auditMetadata = buildInitialAuditMetadata(
    '', // eventId will be generated by database
    actor,
    {
      eldDeviceId,
      eventType,
      eventDate,
      eventTime,
      eventRecordStatus,
      eventRecordOrigin,
    },
    prevChainHash,
    eventDate,
    sha256,
    network
  );

  // Insert event
  const { data: insertedEvent, error } = await supabase
    .from('eld_events')
    .insert({
      event_type: eventType,
      event_sub_type: eventSubType,
      event_record_status: eventRecordStatus,
      event_record_origin: eventRecordOrigin,
      event_sequence_id: sequenceId,
      event_date: eventDate,
      event_time: eventTime,
      timezone_offset: timezoneOffset,
      event_timestamp: eventTimestamp,
      log_period_id: logPeriodId,
      eld_device_id: eldDeviceId,
      driver_eld_account_id: driverEldAccountId,
      carrier_dot_number: carrierDotNumber,
      event_metadata: metadata,
      content_hash: auditMetadata.contentHash,
      chain_hash: auditMetadata.chainHash,
      audit_metadata: auditMetadata,
    })
    .select('id, event_sequence_id, chain_hash')
    .single();

  if (error) {
    // Check for partition-related errors
    if (error.message.includes('no partition') || error.message.includes('partition')) {
      throw new Error(
        `Failed to insert event: No partition exists for timestamp ${eventTimestamp}. ` +
          `Run maintain_eld_events_partitions() to create missing partitions. ` +
          `Original error: ${error.message}`
      );
    }
    throw new Error(`Failed to insert event: ${error.message}`);
  }

  return {
    eventId: insertedEvent.id,
    sequenceId: insertedEvent.event_sequence_id,
    chainHash: insertedEvent.chain_hash,
  };
}

/**
 * Retrieves events for a specific device and log period.
 */
export async function getEventsByDevice(
  eldDeviceId: string,
  logDate: string,
  options?: {
    eventType?: number;
    includeInactive?: boolean;
  }
): Promise<unknown[]> {
  let query = supabase
    .from('eld_events')
    .select('*')
    .eq('eld_device_id', eldDeviceId)
    .eq('log_date', logDate)
    .order('event_sequence_id', { ascending: true });

  if (options?.eventType !== undefined) {
    query = query.eq('event_type', options.eventType);
  }

  if (!options?.includeInactive) {
    query = query.eq('event_record_status', 1);
  }

  const { data, error } = await query;

  if (error) {
    throw new Error(`Failed to fetch events: ${error.message}`);
  }

  return data || [];
}

// ============================================================================
// Batch Event Ingestion
// ============================================================================

/**
 * Loose actor shape accepted by the batch ingestion entry-point.
 * The full AuditActor (from the shared package) requires additional fields that
 * the API layer does not yet supply; the cast to AuditActor is done internally
 * when forwarding to ingestEvent().
 */
export interface BatchActorContext {
  userId: string;
  deviceId?: string;
  source?: string;
  [key: string]: unknown;
}

export interface BatchIngestParams {
  events: Omit<IngestEventParams, 'actor' | 'network'>[];
  actor: BatchActorContext;
  network?: NetworkContext;
}

export interface BatchIngestResult {
  accepted: Array<{
    index: number;
    eventId: string;
    sequenceId: number;
    chainHash: string;
    eventType: number;
  }>;
  rejected: Array<{
    index: number;
    error: string;
    eventType?: number;
    eventSequenceId?: string;
  }>;
  summary: {
    total: number;
    accepted: number;
    rejected: number;
    processingTimeMs: number;
  };
}

/**
 * Ingests a batch of ELD events sequentially to preserve hash chain integrity.
 *
 * Events within a batch are processed one-by-one because each event's chainHash
 * depends on the previous event's chainHash. Processing in parallel would
 * corrupt the audit trail.
 *
 * Processing continues even when individual events fail â€” errors are collected
 * and returned in the `rejected` list alongside accepted results.
 */
export async function ingestBatchEvents(params: BatchIngestParams): Promise<BatchIngestResult> {
  const { events, actor, network } = params;
  const startTime = Date.now();

  const accepted: BatchIngestResult['accepted'] = [];
  const rejected: BatchIngestResult['rejected'] = [];

  for (let i = 0; i < events.length; i++) {
    const event = events[i];
    try {
      const result = await ingestEvent({ ...event, actor: actor as unknown as AuditActor, network });
      accepted.push({
        index: i,
        eventId: result.eventId,
        sequenceId: result.sequenceId,
        chainHash: result.chainHash,
        eventType: event.eventType,
      });
    } catch (err) {
      rejected.push({
        index: i,
        error: err instanceof Error ? err.message : 'Unknown error',
        eventType: event.eventType,
        eventSequenceId: event.sequenceId !== undefined ? String(event.sequenceId) : undefined,
      });
    }
  }

  return {
    accepted,
    rejected,
    summary: {
      total: events.length,
      accepted: accepted.length,
      rejected: rejected.length,
      processingTimeMs: Date.now() - startTime,
    },
  };
}
