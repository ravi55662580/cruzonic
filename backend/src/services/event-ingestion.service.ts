import { supabase } from '../config/supabase';
import { allocateSequenceId, validateSequenceId } from './sequence-id.service';
import {
  buildInitialAuditMetadata,
  AuditActor,
  NetworkContext,
} from '../../../shared/src/eld/audit-trail';
import { createHash } from 'crypto';

interface IngestEventParams {
  eventType: number;
  eventSubType?: number;
  eventRecordStatus: number;
  eventRecordOrigin: number;
  eventDate: string;
  eventTime: string;
  timezoneOffset: string;
  eldDeviceId: string;
  driverEldAccountId?: string;
  carrierDotNumber?: string;
  metadata: Record<string, unknown>;
  actor: AuditActor;
  network?: NetworkContext;
  sequenceId?: number; // Optional - will be allocated if not provided
}

interface IngestEventResult {
  eventId: string;
  sequenceId: number;
  chainHash: string;
}

function sha256(input: string): string {
  return createHash('sha256').update(input, 'utf8').digest('hex');
}

/**
 * Ingests a new ELD event with full audit trail and hash chain verification.
 */
export async function ingestEvent(params: IngestEventParams): Promise<IngestEventResult> {
  const {
    eventType,
    eventSubType,
    eventRecordStatus,
    eventRecordOrigin,
    eventDate,
    eventTime,
    timezoneOffset,
    eldDeviceId,
    driverEldAccountId,
    carrierDotNumber,
    metadata,
    actor,
    network,
    sequenceId: providedSequenceId,
  } = params;

  // Determine log_period_id (YYYYMMDD format)
  const logPeriodId = eventDate;

  // Allocate or validate sequence ID
  let sequenceId: number;
  if (providedSequenceId !== undefined) {
    const validation = await validateSequenceId(eldDeviceId, eventDate, providedSequenceId);
    if (!validation.valid) {
      throw new Error(`Invalid sequence ID: ${validation.reason}`);
    }
    sequenceId = providedSequenceId;
  } else {
    sequenceId = await allocateSequenceId(eldDeviceId, eventDate);
  }

  // Fetch previous event's chain hash
  const { data: prevEvent } = await supabase
    .from('eld_events')
    .select('chain_hash')
    .eq('eld_device_id', eldDeviceId)
    .eq('log_period_id', logPeriodId)
    .eq('event_record_status', 1)
    .order('event_sequence_id', { ascending: false })
    .limit(1)
    .maybeSingle();

  const prevChainHash = prevEvent?.chain_hash || '';

  // Parse event timestamp
  // IMPORTANT: event_timestamp is the PARTITION KEY for eld_events table.
  // PostgreSQL will automatically route this INSERT to the correct monthly partition.
  // If no partition exists for this timestamp, the INSERT will fail.
  const year = `20${eventDate.substring(4, 6)}`;
  const month = eventDate.substring(0, 2);
  const day = eventDate.substring(2, 4);
  const hour = eventTime.substring(0, 2);
  const minute = eventTime.substring(2, 4);
  const second = eventTime.substring(4, 6);
  const tzSign = timezoneOffset[0];
  const tzHour = timezoneOffset.substring(1, 3);
  const tzMin = timezoneOffset.substring(3, 5);
  const eventTimestamp = `${year}-${month}-${day}T${hour}:${minute}:${second}${tzSign}${tzHour}:${tzMin}`;

  // Build audit metadata with hash chain
  const auditMetadata = buildInitialAuditMetadata(
    '', // eventId will be generated by database
    actor,
    {
      eldDeviceId,
      eventType,
      eventDate,
      eventTime,
      eventRecordStatus,
      eventRecordOrigin,
    },
    prevChainHash,
    eventDate,
    sha256,
    network
  );

  // Insert event
  const { data: insertedEvent, error } = await supabase
    .from('eld_events')
    .insert({
      event_type: eventType,
      event_sub_type: eventSubType,
      event_record_status: eventRecordStatus,
      event_record_origin: eventRecordOrigin,
      event_sequence_id: sequenceId,
      event_date: eventDate,
      event_time: eventTime,
      timezone_offset: timezoneOffset,
      event_timestamp: eventTimestamp,
      log_period_id: logPeriodId,
      eld_device_id: eldDeviceId,
      driver_eld_account_id: driverEldAccountId,
      carrier_dot_number: carrierDotNumber,
      event_metadata: metadata,
      content_hash: auditMetadata.contentHash,
      chain_hash: auditMetadata.chainHash,
      audit_metadata: auditMetadata,
    })
    .select('id, event_sequence_id, chain_hash')
    .single();

  if (error) {
    // Check for partition-related errors
    if (error.message.includes('no partition') || error.message.includes('partition')) {
      throw new Error(
        `Failed to insert event: No partition exists for timestamp ${eventTimestamp}. ` +
          `Run maintain_eld_events_partitions() to create missing partitions. ` +
          `Original error: ${error.message}`
      );
    }
    throw new Error(`Failed to insert event: ${error.message}`);
  }

  return {
    eventId: insertedEvent.id,
    sequenceId: insertedEvent.event_sequence_id,
    chainHash: insertedEvent.chain_hash,
  };
}

/**
 * Retrieves events for a specific device and log period.
 */
export async function getEventsByDevice(
  eldDeviceId: string,
  logDate: string,
  options?: {
    eventType?: number;
    includeInactive?: boolean;
  }
): Promise<unknown[]> {
  let query = supabase
    .from('eld_events')
    .select('*')
    .eq('eld_device_id', eldDeviceId)
    .eq('log_date', logDate)
    .order('event_sequence_id', { ascending: true });

  if (options?.eventType !== undefined) {
    query = query.eq('event_type', options.eventType);
  }

  if (!options?.includeInactive) {
    query = query.eq('event_record_status', 1);
  }

  const { data, error } = await query;

  if (error) {
    throw new Error(`Failed to fetch events: ${error.message}`);
  }

  return data || [];
}
